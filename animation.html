<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZIPObject Data Flow Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111827;
            /* bg-gray-900 */
            color: #e5e7eb;
            /* text-gray-200 */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 2rem;
        }

        h1 {
            text-align: center;
            margin-bottom: 2rem;
            font-size: 2.25rem;
            background: linear-gradient(to right, #ffffff, #a1a1aa, #71717a);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .description {
            text-align: center;
            max-width: 800px;
            margin: 0 auto 3rem auto;
            color: #9ca3af;
            /* text-gray-400 */
            font-size: 1.125rem;
            line-height: 1.75;
        }

        #visualization-container {
            width: 100%;
            height: 500px;
            position: relative;
            overflow: hidden;
            border-radius: 0.5rem;
            border: 1px solid #374151;
            /* border-gray-700 */
        }

        .node {
            position: absolute;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }

        .source-node {
            flex-direction: row;
        }

        .node-icon {
            width: 80px;
            height: 80px;
            background-color: #1f2937;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #4b5563;
            margin-bottom: 1rem;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        }

        .node-icon img {
            width: 60%;
            height: 60%;
        }

        .zipobject-icon {
            background: linear-gradient(135deg, #1f2937, #2d3748);
            border: 2px solid #9ca3af;
        }

        .node-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: white;
            text-align: center;
            background-color: rgba(31, 41, 55, 0.9);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>How ZIPObject Works</h1>
        <div class="description">
            ZIPObject provides file context for the intelligent internet, allowing AI agents to access, search through,
            and understand any filesystem. See how data flows from various sources to your AI agents.
        </div>

        <div id="visualization-container">
            <!-- Nodes will be added here -->
            <div class="node source-node" style="top: 35%; left: 20%;">
                <div class="node-label"
                    style="position: absolute; left: -200px; top: 10px; width: 150px; text-align: right;">GitHub
                    Repositories</div>
                <div class="node-icon">
                    <img src="data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjZmZmZmZmIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIC4yOTdjLTYuNjMgMC0xMiA1LjM3My0xMiAxMiAwIDUuMzAzIDMuNDM4IDkuOCA4LjIwNSAxMS4zODUuNi4xMTMuODItLjI1OC44Mi0uNTc3IDAtLjI4NS0uMDEtMS4wNC0uMDE1LTIuMDQtMy4zMzguNzI0LTQuMDQyLTEuNjEtNC4wNDItMS42MUM0LjQyMiAxOC4wNyAzLjYzMyAxNy43IDMuNjMzIDE3LjdjLTEuMDg3LS43NDQuMDg0LS43MjkuMDg0LS43MjkgMS4yMDUuMDg0IDEuODM4IDEuMjM2IDEuODM4IDEuMjM2IDEuMDcgMS44MzUgMi44MDkgMS4zMDUgMy40OTUuOTk4LjEwOC0uNzc2LjQxNy0xLjMwNS43Ni0xLjYwNS0yLjY2NS0uMy01LjQ2Ni0xLjMzMi01LjQ2Ni01LjkzIDAtMS4zMS40NjUtMi4zOCAxLjIzNS0zLjIyLS4xMzUtLjMwMy0uNTQtMS41MjMuMTA1LTMuMTc2IDAgMCAxLjAwNS0uMzIyIDMuMyAxLjIzLjk2LS4yNjcgMS45OC0uMzk5IDMtLjQwNSAxLjAyLjAwNiAyLjA0LjEzOCAzIC40MDUgMi4yOC0xLjU1MiAzLjI4NS0xLjIzIDMuMjg1LTEuMjMuNjQ1IDEuNjUzLjI0IDIuODczLjEyIDMuMTc2Ljc2NS44NCAxLjIzIDEuOTEgMS4yMyAzLjIyIDAgNC42MS0yLjgwNSA1LjYyNS01LjQ3NSA1LjkyLjQyLjM2LjgxIDEuMDk2LjgxIDIuMjIgMCAxLjYwNi0uMDE1IDIuODk2LS4wMTUgMy4yODYgMCAuMzE1LjIxLjY5LjgyNS41N0MyMC41NjUgMjIuMDkyIDI0IDE3LjU5MiAyNCAxMi4yOTdjMC02LjYyNy01LjM3My0xMi0xMi0xMiIvPjwvc3ZnPg=="
                        alt="GitHub">
                </div>
            </div>

            <div class="node source-node" style="top: 50%; left: 20%;">
                <div class="node-label"
                    style="position: absolute; left: -200px; top: 10px; width: 150px; text-align: right;">NPM Packages
                </div>
                <div class="node-icon">
                    <img src="data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjQ0IzODM3IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTAgMHYyNGgyNFYwSDB6bTYuODE3IDYuODE3aDEwLjM2NnYxMC4zNjZINi44MTdWNi44MTd6bTUuMTgzIDUuMTgzVjguNDVoNS4xODN2Ny43MzNoLTIuNTkxdi01LjE4M2gtMi41OTJ6Ii8+PC9zdmc+"
                        alt="NPM">
                </div>
            </div>

            <div class="node source-node" style="top: 65%; left: 20%;">
                <div class="node-label"
                    style="position: absolute; left: -200px; top: 10px; width: 150px; text-align: right;">ZIP/Tarball
                    Files</div>
                <div class="node-icon">
                    <img src="data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjZmZmZmZmIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTIxLjYgMEgyLjRDMS4wOCAwIDAgMS4wOCAwIDIuNHYxOS4yQzAgMjIuOTIgMS4wOCAyNCAyLjQgMjRoMTkuMmMxLjMyIDAgMi40LTEuMDggMi40LTIuNFYyLjRDMjQgMS4wOCAyMi45MiAwIDIxLjYgMHpNMTQuNCAyLjRoMi40VjZoLTIuNFYyLjR6bS0zLjYgMGgyLjRWNmgtMi40VjIuNHpNNy4yIDIuNGgyLjRWNkg3LjJWMi40ek0zLjYgMi40aDIuNFY2SDMuNlYyLjR6bTAgNmgxNi44djEySDMuNlY4LjR6Ii8+PC9zdmc+"
                        alt="ZIP/Tarball">
                </div>
            </div>

            <div class="node" style="top: 50%; left: 50%;">
                <div class="node-icon zipobject-icon">
                    <img src="data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjZmZmZmZmIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEzLjU5IDcuNTlMMTkgMTNsLTUuNDEgNS40MS0xLjQxLTEuNDEgMy41OC0zLjU5LTkuNzYtLjAxdi0yaDkuNzZsLTMuNTktMy41OUwxMy41OSA3LjU5ek0yMSAzYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMkgzYTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDE4em0wIDE2VjVIM3YxNGgxOHoiLz48L3N2Zz4="
                        alt="ZIPObject">
                </div>
                <div class="node-label">ZIPObject</div>
            </div>

            <div class="node" style="top: 50%; left: 80%;">
                <div class="node-icon">
                    <img src="data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjZmZmZmZmIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDJDMTMuMSAyIDE0IDIuOSAxNCA0QzE0IDUuMSAxMy4xIDYgMTIgNkMxMC45IDYgMTAgNS4xIDEwIDRDMTAgMi45IDEwLjkgMiAxMiAyTTE1LjkgOC4xQzE1LjUgNy43IDE0LjggNyAxMy41IDdIMTFDOC4yIDcgNiA0LjggNiAySDRDNCA1LjIgNi4xIDcuOCA5IDguN1YyMkgxMVYxNkgxM1YyMkgxNVYxMC4xTDE5IDE0TDIwLjQgMTIuNkwxNS45IDguMVoiLz48L3N2Zz4="
                        alt="AI Agent">
                </div>
                <div class="node-label">AI Agent</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const container = document.getElementById('visualization-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setClearColor(0x1f2937, 1); // bg-gray-800

        // Insert the renderer at the beginning of the container so it's behind other elements
        container.insertBefore(renderer.domElement, container.firstChild);

        // Define node positions for the particle system
        const nodePositions = [
            { x: -6, y: -1.5, z: 0 }, // GitHub
            { x: -6, y: 0, z: 0 },    // NPM
            { x: -6, y: 1.5, z: 0 },  // ZIP
            { x: 0, y: 0, z: 0 },     // ZIPObject
            { x: 6, y: 0, z: 0 }      // AI Agent
        ];

        // Create particles for animated flow
        const particlesCount = 200;
        const particles = new THREE.BufferGeometry();
        const particleMaterial = new THREE.PointsMaterial({
            color: 0x63b3ed, // blue-400
            size: 0.2,
            transparent: true,
            opacity: 0.8
        });

        // Paths for particles
        const paths = [
            // Left sources to ZIPObject
            { start: { x: -6, y: -1.5, z: 0 }, end: { x: 0, y: 0, z: 0 } },
            { start: { x: -6, y: 0, z: 0 }, end: { x: 0, y: 0, z: 0 } },
            { start: { x: -6, y: 1.5, z: 0 }, end: { x: 0, y: 0, z: 0 } },
            // ZIPObject to AI Agent
            { start: { x: 0, y: 0, z: 0 }, end: { x: 6, y: 0, z: 0 } }
        ];

        // Create particles with positions and custom attributes
        const positions = new Float32Array(particlesCount * 3);
        const pathIndices = new Float32Array(particlesCount);
        const progressValues = new Float32Array(particlesCount);

        for (let i = 0; i < particlesCount; i++) {
            // Randomly assign each particle to a path
            const pathIndex = Math.floor(Math.random() * paths.length);
            const path = paths[pathIndex];
            pathIndices[i] = pathIndex;

            // Random progress along the path (0 to 1)
            const progress = Math.random();
            progressValues[i] = progress;

            // Interpolate position based on progress
            const x = path.start.x + (path.end.x - path.start.x) * progress;
            const y = path.start.y + (path.end.y - path.start.y) * progress;
            const z = path.start.z + (path.end.z - path.start.z) * progress;

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;
        }

        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('pathIndex', new THREE.BufferAttribute(pathIndices, 1));
        particles.setAttribute('progress', new THREE.BufferAttribute(progressValues, 1));

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update particle positions
            const positions = particles.attributes.position.array;
            const pathIndices = particles.attributes.pathIndex.array;
            const progressValues = particles.attributes.progress.array;

            for (let i = 0; i < particlesCount; i++) {
                // Update progress
                progressValues[i] += 0.008;
                if (progressValues[i] > 1) {
                    progressValues[i] = 0;
                }

                // Get current path
                const pathIndex = pathIndices[i];
                const path = paths[pathIndex];

                // Interpolate new position
                const x = path.start.x + (path.end.x - path.start.x) * progressValues[i];
                const y = path.start.y + (path.end.y - path.start.y) * progressValues[i];
                const z = path.start.z + (path.end.z - path.start.z) * progressValues[i];

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }

            particles.attributes.position.needsUpdate = true;
            particles.attributes.progress.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(newWidth, newHeight);
        });

        animate();
    </script>
</body>

</html>